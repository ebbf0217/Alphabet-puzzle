<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
<title>FOR EILEEN</title>
<style>
  :root{
    /* Bold, flat-ish cute theme: GREEN + ORANGE */
    --g:#16d15d;         /* bright green */
    --g2:#0fb24b;        /* deep green */
    --o:#ff8a1d;         /* bright orange */
    --o2:#ff6a00;        /* deep orange */
    --y:#ffe34d;         /* cute lemon */
    --ink:#123228;
    --muted:#2b6b52;

    --bg1:#eafff1;
    --bg2:#fff2da;

    --card:#ffffff;
    --line:rgba(18,50,40,.14);
    --shadow: 0 18px 38px rgba(18,50,40,.14);

    --danger:#ff3b3b;
    --dangerBg: rgba(255,59,59,.12);

    --gap:8px;
    --cellSize:56px; /* auto-fit by JS */
  }

  *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
  html,body{ height:100%; }
  body{
    margin:0;
    font-family: ui-rounded, system-ui, -apple-system, "Segoe UI", sans-serif;
    color:var(--ink);
    background:
      radial-gradient(900px 480px at 18% 10%, rgba(22,209,93,.28) 0%, transparent 60%),
      radial-gradient(900px 520px at 88% 18%, rgba(255,138,29,.30) 0%, transparent 60%),
      linear-gradient(135deg, var(--bg1), var(--bg2));
    display:flex;
    justify-content:center;
    overflow:hidden;
  }

  .app{
    width:min(540px, 96vw);
    height:100dvh;
    padding:12px 12px calc(12px + env(safe-area-inset-bottom));
    display:flex;
    flex-direction:column;
    gap:10px;
    overflow:hidden;
  }

  /* Cute card system */
  .card{
    background: var(--card);
    border:2px solid rgba(18,50,40,.10);
    border-radius:20px;
    box-shadow: var(--shadow);
    position:relative;
    overflow:hidden;
  }
  .card:before{
    content:"";
    position:absolute;
    inset:-40px -40px auto auto;
    width:140px; height:140px;
    background: radial-gradient(circle at 30% 30%, rgba(255,227,77,.85), rgba(255,227,77,0));
    transform: rotate(12deg);
    pointer-events:none;
  }
  .card:after{
    content:"";
    position:absolute;
    inset:auto auto -52px -52px;
    width:160px; height:160px;
    background: radial-gradient(circle at 70% 70%, rgba(22,209,93,.30), rgba(22,209,93,0));
    pointer-events:none;
  }

  /* Top bar */
  .top{
    padding:10px 12px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
  }

  .brand{
    display:flex; align-items:center; gap:10px; min-width:0;
  }
  .logo{
    width:36px; height:36px;
    border-radius:16px;
    background: conic-gradient(from 180deg, var(--g), var(--o), var(--y), var(--g2), var(--o2), var(--g));
    box-shadow: 0 12px 22px rgba(22,209,93,.20);
    border:2px solid rgba(255,255,255,.8);
    flex:0 0 auto;
  }
  .brandText{ min-width:0; }
  .brandText h1{
    margin:0;
    font-size:14px;
    letter-spacing:.5px;
    line-height:1.1;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .brandText p{
    margin:2px 0 0;
    font-size:11px;
    color:rgba(18,50,40,.70);
    line-height:1.1;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }

  .stats{
    display:flex;
    align-items:center;
    gap:8px;
    flex:0 0 auto;
  }
  .pill{
    padding:8px 10px;
    border-radius:999px;
    border:2px solid rgba(18,50,40,.10);
    background: linear-gradient(135deg, rgba(22,209,93,.10), rgba(255,138,29,.10));
    font-size:12px;
    font-weight:1000;
    white-space:nowrap;
  }
  .reset{
    border:none;
    background: linear-gradient(135deg, var(--g2), var(--o2));
    color:#fff;
    border-radius:14px;
    padding:8px 10px;
    font-weight:1000;
    cursor:pointer;
    box-shadow: 0 14px 20px rgba(255,106,0,.22);
  }
  .reset:active{ transform: scale(.98); }

  /* Target */
  .target{
    padding:10px 12px 12px;
  }
  .targetHead{
    display:flex;
    align-items:flex-end;
    justify-content:space-between;
    gap:10px;
    flex-wrap:wrap;
  }
  .targetHead h2{
    margin:0;
    font-size:14px;
    letter-spacing:.2px;
  }
  .sub{
    margin:4px 0 0;
    color:rgba(18,50,40,.68);
    font-size:11px;
    line-height:1.25;
  }

  .slotsRow{
    margin-top:10px;
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    align-items:center;
  }

  .slot{
    width:calc(var(--cellSize) * 0.92);
    height:calc(var(--cellSize) * 0.92);
    border-radius:18px;
    background: linear-gradient(135deg, rgba(22,209,93,.20), rgba(255,138,29,.20));
    border:3px dashed rgba(18,50,40,.16);
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:22px;
    font-weight:1100;
    user-select:none;
    cursor:pointer;
    color: rgba(18,50,40,.22);
    transition: transform .10s ease, border-color .10s ease, background .10s ease, color .10s ease, box-shadow .10s ease;
  }
  .slot:active{ transform: scale(.98); }

  .slot.filled{
    border-style:solid;
    background: linear-gradient(135deg, rgba(22,209,93,.35), rgba(255,227,77,.35));
    border-color: rgba(22,209,93,.55);
    color: rgba(18,50,40,.95);
    box-shadow: 0 14px 18px rgba(18,50,40,.10);
  }
  .slot.armed{
    border-color: rgba(255,106,0,.55);
    box-shadow: 0 14px 20px rgba(255,106,0,.16);
  }
  .slot.match{
    border-style:solid;
    border-color: rgba(22,209,93,.75);
    box-shadow: 0 14px 20px rgba(22,209,93,.16);
  }

  .slot.wrong{
    border-style:solid;
    border-color: rgba(255,59,59,.70);
    background: linear-gradient(135deg, var(--dangerBg), rgba(255,227,77,.10));
    animation: shake .22s ease-in-out;
  }
  @keyframes shake{
    0%{ transform: translateX(0); }
    25%{ transform: translateX(-6px); }
    50%{ transform: translateX(6px); }
    75%{ transform: translateX(-4px); }
    100%{ transform: translateX(0); }
  }

  /* Progress bar */
  .progressWrap{
    margin-top:10px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
  }
  .bar{
    flex:1;
    height:14px;
    border-radius:999px;
    background: rgba(18,50,40,.10);
    overflow:hidden;
    border:2px solid rgba(18,50,40,.10);
  }
  .barFill{
    height:100%;
    width:0%;
    background: linear-gradient(135deg, var(--g2), var(--o2));
    border-radius:999px;
    transition: width .22s ease;
  }
  .barText{
    font-size:12px;
    font-weight:1100;
    white-space:nowrap;
    color: rgba(18,50,40,.90);
  }

  /* Selection chip */
  .selection{
    margin-top:8px;
    border-radius:18px;
    border:2px solid rgba(18,50,40,.10);
    background: linear-gradient(135deg, rgba(22,209,93,.10), rgba(255,138,29,.10));
    padding:9px 10px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
  }
  .selection .t{
    font-size:11px;
    font-weight:1100;
    color: rgba(18,50,40,.90);
  }
  .selection .g{
    font-size:11px;
    font-weight:900;
    color: rgba(18,50,40,.60);
  }
  .selection .big{
    font-size:18px;
    font-weight:1100;
  }

  /* Grid card */
  .gridCard{
    padding:10px 12px 12px;
    display:flex;
    flex-direction:column;
    gap:8px;
    flex:1;
    min-height:0;
  }

  .miniTip{
    margin:0;
    font-size:11px;
    color: rgba(18,50,40,.70);
    line-height:1.2;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:8px;
  }
  .miniTip b{ color: rgba(18,50,40,.95); }
  .miniTip .loading{
    display:inline-flex; align-items:center; gap:6px;
    font-weight:1000;
  }
  .spinner{
    width:12px; height:12px;
    border-radius:50%;
    border:2px solid rgba(18,50,40,.18);
    border-top-color: rgba(255,106,0,.85);
    animation: spin .7s linear infinite;
  }
  @keyframes spin { to{ transform: rotate(360deg);} }

  .grid{
    display:grid;
    grid-template-columns: repeat(5, var(--cellSize));
    grid-template-rows: repeat(5, var(--cellSize));
    gap:var(--gap);
    justify-content:center;
    align-content:center;
    flex:1;
    min-height:0;
  }
  .cell{
    width:var(--cellSize);
    height:var(--cellSize);
    border-radius:20px;
    background: linear-gradient(135deg, #ffffff, rgba(22,209,93,.10));
    border:2px solid rgba(18,50,40,.10);
    box-shadow: 0 14px 18px rgba(18,50,40,.10);
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:22px;
    font-weight:1100;
    user-select:none;
    cursor:pointer;
    transition: transform .10s ease, outline-color .10s ease, opacity .18s ease;
    position:relative;
  }
  .cell:active{ transform: scale(.98); }
  .cell.selected{
    outline: 4px solid rgba(255,106,0,.55);
    outline-offset: 2px;
    transform: translateY(-1px);
  }
  .cell.matchHint{
    outline: 4px solid rgba(22,209,93,.28);
    outline-offset: 2px;
  }
  .cell.pop{ animation: pop .16s ease-in-out; }
  @keyframes pop{
    0%{ transform: scale(.98); }
    60%{ transform: scale(1.07); }
    100%{ transform: scale(1); }
  }

  /* ‚ÄúTetris clear‚Äù effect */
  .cell.clearing{
    animation: clearDrop .35s ease forwards;
  }
  @keyframes clearDrop{
    0%{ opacity:1; transform: translateY(0) scale(1); }
    70%{ opacity:.9; transform: translateY(16px) scale(.98); }
    100%{ opacity:0; transform: translateY(44px) scale(.94); }
  }

  /* Bottom */
  .bottom{
    padding:10px 12px 12px;
    display:flex;
    gap:10px;
    align-items:flex-start;
  }
  .miniCol{
    flex:1;
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  .label{
    font-size:11px;
    font-weight:1100;
    color: rgba(18,50,40,.90);
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:8px;
  }
  .label span{
    color: rgba(18,50,40,.62);
    font-weight:1000;
    white-space:nowrap;
  }

  /* Storage (tiny) */
  .storageRow{
    display:flex;
    gap:6px;
    flex-wrap:nowrap;
  }
  .stash{
    width:34px;
    height:34px;
    border-radius:14px;
    background: rgba(255,255,255,.80);
    border:2px dashed rgba(18,50,40,.22);
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:1100;
    font-size:16px;
    color: rgba(18,50,40,.86);
    user-select:none;
    cursor:pointer;
    flex:0 0 auto;
    transition: transform .08s ease, outline-color .08s ease, border-color .08s ease;
  }
  .stash:active{ transform: scale(.98); }
  .stash.filled{
    background: linear-gradient(135deg, rgba(255,138,29,.16), rgba(22,209,93,.16));
    border-style:solid;
  }
  .stash.selected{
    outline: 4px solid rgba(22,209,93,.45);
    outline-offset: 2px;
  }

  /* Items */
  .itemsRow{
    display:flex;
    gap:8px;
    align-items:center;
    flex-wrap:nowrap;
  }
  .itemBtn{
    position:relative;
    width:42px;
    height:42px;
    border-radius:16px;
    border:2px solid rgba(18,50,40,.10);
    background: linear-gradient(135deg, rgba(255,138,29,.16), rgba(22,209,93,.16));
    box-shadow: 0 14px 18px rgba(18,50,40,.10);
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    user-select:none;
    transition: transform .08s ease;
    flex:0 0 auto;
  }
  .itemBtn:active{ transform: scale(.98); }
  .itemIcon{
    font-size:18px;
    filter: drop-shadow(0 8px 10px rgba(18,50,40,.16));
  }
  .badge{
    position:absolute;
    right:-6px;
    top:-6px;
    min-width:18px;
    height:18px;
    padding:0 5px;
    border-radius:999px;
    background: linear-gradient(135deg, var(--g2), var(--o2));
    color:#fff;
    font-size:11px;
    font-weight:1100;
    display:flex;
    align-items:center;
    justify-content:center;
    border:2px solid rgba(255,255,255,.95);
  }
  .itemBtn.disabled{
    opacity:.45;
    filter: grayscale(.2);
  }

  .toast{
    position:fixed;
    left:50%;
    transform:translateX(-50%);
    bottom:calc(14px + env(safe-area-inset-bottom));
    padding:10px 12px;
    border-radius:999px;
    background: rgba(255,255,255,.96);
    border:2px solid rgba(18,50,40,.10);
    box-shadow: var(--shadow);
    font-size:13px;
    font-weight:1100;
    color: rgba(18,50,40,.94);
    opacity:0;
    pointer-events:none;
    transition: opacity .18s ease, transform .18s ease;
    z-index:999;
  }
  .toast.show{
    opacity:1;
    transform:translateX(-50%) translateY(-2px);
  }

  @media (max-width: 420px){
    .stash{ width:32px; height:32px; font-size:15px; }
    .itemBtn{ width:40px; height:40px; }
  }
</style>
</head>
<body>
<div class="app">

  <!-- TOP -->
  <div class="card top">
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div class="brandText">
        <h1>FOR EILEEN</h1>
        <p>Tap to merge ¬∑ Tap to solve ¬∑ Cute & bold</p>
      </div>
    </div>
    <div class="stats">
      <div class="pill">Lv <span id="level">1</span></div>
      <div class="pill">Score <span id="score">0</span></div>
      <button class="reset" id="resetBtn">Reset</button>
    </div>
  </div>

  <!-- TARGET -->
  <div class="card target">
    <div class="targetHead">
      <div>
        <h2>Target Word</h2>
        <div class="sub" id="targetHint"></div>
      </div>
      <div class="sub" style="font-weight:1100;">Tap letter ‚Üí tap slot</div>
    </div>

    <div class="slotsRow" id="targetSlots"></div>

    <div class="progressWrap">
      <div class="bar"><div class="barFill" id="barFill"></div></div>
      <div class="barText" id="barText">0/1</div>
    </div>

    <div class="selection">
      <div>
        <div class="t">Selected</div>
        <div class="g" id="selText">Nothing</div>
      </div>
      <div class="big" id="selBig">‚Äî</div>
    </div>
  </div>

  <!-- GRID -->
  <div class="card gridCard">
    <p class="miniTip" id="miniTip">
      <span><b>Merge</b> same letters (A+A‚ÜíB). <b>Store</b> letters below.</span>
      <span class="loading" id="loadingPill" style="display:none;"><span class="spinner"></span>Loading words‚Ä¶</span>
    </p>
    <div class="grid" id="grid"></div>
  </div>

  <!-- BOTTOM -->
  <div class="card bottom">
    <div class="miniCol">
      <div class="label">Storage <span>(board ‚Üí empty)</span></div>
      <div class="storageRow" id="storageSlots"></div>
    </div>

    <div class="miniCol" style="max-width:240px;">
      <div class="label">Items <span>(tap to use)</span></div>
      <div class="itemsRow">
        <div class="itemBtn" id="itemBomb" title="Boom Reset: clear & refill letters">
          <div class="itemIcon">üí•</div><div class="badge" id="bombCount">0</div>
        </div>
        <div class="itemBtn" id="itemAllA" title="All A: turn all letters into A">
          <div class="itemIcon">üçè</div><div class="badge" id="allACount">0</div>
        </div>
        <div class="itemBtn" id="itemPass" title="Free Pass: solve this target instantly">
          <div class="itemIcon">ü™Ω</div><div class="badge" id="passCount">0</div>
        </div>
      </div>
      <div class="sub" style="margin:8px 0 0;" id="difficultyHint"></div>
    </div>
  </div>

</div>

<div class="toast" id="toast">Hi!</div>

<script>
/* =============================
   FOR EILEEN - FINAL
   Features included:
   - 5x5 grid (auto-fit, no scroll)
   - tap-to-solve (board letter -> target slot)
   - tap-to-merge (board letter -> same board letter)
   - small 5-slot storage (tap-based store/swap)
   - level progress: need solves = level (1,2,3...)
   - level up: tetris-like clear effect + bonus score + letters reset
   - items (3): bomb reset, all A, free pass
     -> grant 1 random item every level up, click to use
   - word bank: loads big english dictionary list (>= 3x) via fetch
   - no repeated target words (persist via localStorage)
   - cute bold orange/green card UI
============================= */

const SIZE = 5;
const LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");

/* --- DOM --- */
const elLevel = document.getElementById("level");
const elScore = document.getElementById("score");
const elGrid = document.getElementById("grid");
const elTargetSlots = document.getElementById("targetSlots");
const elTargetHint = document.getElementById("targetHint");
const elDifficultyHint = document.getElementById("difficultyHint");
const elSelText = document.getElementById("selText");
const elSelBig = document.getElementById("selBig");
const elStorageSlots = document.getElementById("storageSlots");
const elBarFill = document.getElementById("barFill");
const elBarText = document.getElementById("barText");
const elLoadingPill = document.getElementById("loadingPill");

const elBombCount = document.getElementById("bombCount");
const elAllACount = document.getElementById("allACount");
const elPassCount = document.getElementById("passCount");

const elItemBomb = document.getElementById("itemBomb");
const elItemAllA = document.getElementById("itemAllA");
const elItemPass = document.getElementById("itemPass");

/* --- State --- */
let level = 1;
let score = 0;

let grid = [];                     // 5x5
let storage = Array(5).fill(null); // tiny slots

let targetWord = "";
let targetFilled = [];

let pick = null; // {source:'grid', r,c, letter} OR {source:'storage', idx, letter}

/* progress: arithmetic sequence */
let solvesThisLevel = 0;
const requiredSolvesForLevel = (lv) => lv;

/* Items inventory */
const items = { bomb:0, allA:0, pass:0 };

/* --- Word bank & no-repeat --- */
let WORD_BANK = [];               // all candidates (uppercase)
let BANK_READY = false;
const USED_KEY = "for_eileen_used_words_v1";
let USED_SET = new Set();

/* fallback (if fetch fails) */
const FALLBACK_WORDS = [
  "BAD","BAG","BAR","BAT","CAB","CAN","CAP","CAR","CAT","DAD","DAY","EAR","EAT","FAR","FAT","GAS","GAP","HAT","HAD",
  "BARK","BAND","BANK","BEAR","BEAT","BELL","BEND","BIRD","BITE","BOAT","BOOK","CAMP","CART","CAVE","CODE","COOL","COLD",
  "DARK","DEAL","DEEP","DICE","DISH","ECHO","FIRE","FISH","FORK","GAME","GATE","GOLD","GOOD","HOME",
  "APPLE","BRICK","CLOUD","DANCE","GLASS","GREEN","HONEY","HOUSE","LIGHT","MOUSE","MUSIC","NIGHT","OCEAN","PLANE",
  "PLANT","POINT","POWER","RIVER","SHEEP","SHARK","SNAKE","SUGAR","TABLE","TRAIN","ORANGE","GARDEN","FAMILY","WINTER","SUMMER",
  "JAZZ","QUIZ","JINX","VEX","WAX","YAWN","ZANY","ZOOM","ZEST","ZERO","ZEBRA"
];

/* =============================
   UTIL
============================= */
function toast(msg){
  const t = document.getElementById("toast");
  t.textContent = msg;
  t.classList.add("show");
  setTimeout(()=>t.classList.remove("show"), 950);
}
function animateCell(r,c){
  const el = document.getElementById(`cell-${r}-${c}`);
  if(!el) return;
  el.classList.remove("pop");
  void el.offsetWidth;
  el.classList.add("pop");
}
function pulseWrong(slotEl){
  slotEl.classList.remove("wrong");
  void slotEl.offsetWidth;
  slotEl.classList.add("wrong");
  setTimeout(()=>slotEl.classList.remove("wrong"), 260);
}
function clearPick(){ pick = null; }
function updateSelectionChip(){
  if(!pick){
    elSelText.textContent = "Nothing";
    elSelBig.textContent = "‚Äî";
    return;
  }
  if(pick.source === "grid"){
    elSelText.textContent = "Board letter selected";
    elSelBig.textContent = pick.letter;
  } else {
    elSelText.textContent = "Storage letter selected";
    elSelBig.textContent = pick.letter;
  }
}

/* =============================
   AUTO-FIT (no scroll on iPhone)
============================= */
function autoFitCellSize(){
  // Compute max cellSize to fit vertical layout without scrolling.
  const app = document.querySelector(".app");
  const h = app.clientHeight;

  // Estimate fixed heights: top+target+bottom+gaps
  // We'll just compute available space for grid card inner area
  const cards = app.querySelectorAll(".card");
  // Quick approach: temporarily set cellSize and then shrink if overflow
  let size = 62;
  const minSize = 46;

  const root = document.documentElement;
  while(size >= minSize){
    root.style.setProperty("--cellSize", `${size}px`);
    // Force reflow and check overflow
    const scroll = app.scrollHeight;
    if(scroll <= h + 1) break;
    size -= 1;
  }
}

/* =============================
   LETTER SPAWN (rarity)
============================= */
function rarityAlphaForLevel(lv){
  // Later letters rarer as levels increase
  return Math.min(3.0, 1.15 + lv * 0.10);
}
function randomLetterByLevel(lv){
  const alpha = rarityAlphaForLevel(lv);
  let sum = 0;
  const weights = [];
  for(let i=0;i<LETTERS.length;i++){
    const w = 1 / Math.pow(i+1, alpha);
    weights.push(w);
    sum += w;
  }
  let r = Math.random() * sum;
  for(let i=0;i<weights.length;i++){
    r -= weights[i];
    if(r <= 0) return LETTERS[i];
  }
  return "A";
}
function nextLetter(ch){
  const i = LETTERS.indexOf(ch);
  return (i >= 0 && i < 25) ? LETTERS[i+1] : "Z";
}

/* =============================
   DIFFICULTY (target selection)
   Early: short + early letters
   Later: longer + allows late letters
============================= */
function letterIndex(ch){ return LETTERS.indexOf(ch); }
function wordMaxLetterIndex(word){
  let m=0;
  for(const ch of word) m = Math.max(m, letterIndex(ch));
  return m;
}
function levelParams(lv){
  // tuned for 5x5 board (fair progression)
  if(lv <= 2)  return {lenMin:3, lenMax:3, cap:"H"};
  if(lv <= 5)  return {lenMin:3, lenMax:4, cap:"K"};
  if(lv <= 9)  return {lenMin:4, lenMax:4, cap:"N"};
  if(lv <= 14) return {lenMin:4, lenMax:5, cap:"R"};
  if(lv <= 20) return {lenMin:5, lenMax:6, cap:"V"};
  return          {lenMin:5, lenMax:7, cap:"Z"};
}

/* =============================
   WORD BANK LOADING (big dictionary)
   - Loads from a public list (dwyl words_alpha.txt)
   - Filters: letters only, 3..7 length
   - Stores used words in localStorage to avoid repeats
============================= */
function loadUsedSet(){
  try{
    const raw = localStorage.getItem(USED_KEY);
    if(!raw) return;
    const arr = JSON.parse(raw);
    if(Array.isArray(arr)){
      USED_SET = new Set(arr);
    }
  } catch { /* ignore */ }
}
function saveUsedSet(){
  try{
    // Keep size reasonable: if it grows huge, store only last 25000
    const arr = Array.from(USED_SET);
    const trimmed = arr.length > 25000 ? arr.slice(arr.length - 25000) : arr;
    localStorage.setItem(USED_KEY, JSON.stringify(trimmed));
  } catch { /* ignore */ }
}

async function loadWordBank(){
  loadUsedSet();
  elLoadingPill.style.display = "inline-flex";

  // Source: big plain text word list
  // Note: This works on GitHub Pages (CORS OK).
  const URL = "https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt";

  try{
    const res = await fetch(URL, {cache:"force-cache"});
    if(!res.ok) throw new Error("Fetch failed");
    const text = await res.text();

    // Parse efficiently
    const lines = text.split(/\r?\n/);
    const bank = [];
    for(const w of lines){
      if(!w) continue;
      const L = w.length;
      if(L < 3 || L > 7) continue;
      // letters only
      let ok = true;
      for(let i=0;i<L;i++){
        const c = w.charCodeAt(i);
        if(c < 97 || c > 122){ ok=false; break; } // a-z only
      }
      if(!ok) continue;
      bank.push(w.toUpperCase());
      // performance cap (still enormous; plenty of variety)
      if(bank.length >= 30000) break;
    }

    WORD_BANK = bank.length ? bank : FALLBACK_WORDS.slice();
    BANK_READY = true;
    toast(`Words loaded: ${WORD_BANK.length.toLocaleString()}`);
  } catch(e){
    WORD_BANK = FALLBACK_WORDS.slice();
    BANK_READY = true;
    toast("Word list offline ‚Üí using fallback words");
  } finally {
    elLoadingPill.style.display = "none";
    renderAll();
  }
}

/* pick a non-repeating target word from bank */
function pickTargetWord(){
  if(!BANK_READY || !WORD_BANK.length){
    targetWord = "CAT";
    targetFilled = Array.from({length: targetWord.length}, () => false);
    return;
  }

  const p = levelParams(level);
  const capIdx = letterIndex(p.cap);

  // candidates indices (avoid building huge array each time -> do random tries)
  // We'll do up to N random attempts; if can't find, relax constraints.
  function isAllowed(word){
    if(word.length < p.lenMin || word.length > p.lenMax) return false;
    if(wordMaxLetterIndex(word) > capIdx) return false;
    return true;
  }

  // Try strict first
  let chosen = null;
  for(let tries=0; tries<800; tries++){
    const w = WORD_BANK[(Math.random() * WORD_BANK.length) | 0];
    if(!isAllowed(w)) continue;
    if(USED_SET.has(w)) continue;
    chosen = w; break;
  }

  // Relax if needed: length only
  if(!chosen){
    for(let tries=0; tries<1000; tries++){
      const w = WORD_BANK[(Math.random() * WORD_BANK.length) | 0];
      if(w.length < p.lenMin || w.length > p.lenMax) continue;
      if(USED_SET.has(w)) continue;
      chosen = w; break;
    }
  }

  // If still none, reset used set (word bank "exhausted" for this window)
  if(!chosen){
    USED_SET.clear();
    saveUsedSet();
    chosen = WORD_BANK[(Math.random() * WORD_BANK.length) | 0];
  }

  targetWord = chosen;
  targetFilled = Array.from({length: targetWord.length}, () => false);

  USED_SET.add(targetWord);
  saveUsedSet();
}

/* =============================
   BOARD
============================= */
function fillBoardFull(){
  grid = Array.from({length: SIZE}, () =>
    Array.from({length: SIZE}, () => randomLetterByLevel(level))
  );
}
function refillCell(r,c){
  grid[r][c] = randomLetterByLevel(level);
}

/* =============================
   ITEMS
============================= */
function updateItemsUI(){
  elBombCount.textContent = String(items.bomb);
  elAllACount.textContent = String(items.allA);
  elPassCount.textContent = String(items.pass);

  elItemBomb.classList.toggle("disabled", items.bomb <= 0);
  elItemAllA.classList.toggle("disabled", items.allA <= 0);
  elItemPass.classList.toggle("disabled", items.pass <= 0);
}

function grantRandomItem(){
  const pool = ["bomb","allA","pass"];
  const got = pool[(Math.random()*pool.length)|0];
  items[got] += 1;
  updateItemsUI();

  if(got==="bomb") toast("Item +1 üí• (Boom Reset)");
  if(got==="allA") toast("Item +1 üçè (All A)");
  if(got==="pass") toast("Item +1 ü™Ω (Free Pass)");
}

async function clearBoardEffectAndRefill(bonusScore=0){
  const nodes = [];
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      const el = document.getElementById(`cell-${r}-${c}`);
      if(el) nodes.push({el, r, c});
    }
  }
  // bottom-up wave
  nodes.sort((a,b)=> (b.r-a.r) || (a.c-b.c));
  nodes.forEach((n, idx) => setTimeout(()=>n.el.classList.add("clearing"), idx*18));

  await new Promise(res => setTimeout(res, nodes.length*18 + 430));

  // refill letters
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      grid[r][c] = randomLetterByLevel(level);
    }
  }
  nodes.forEach(n=>n.el.classList.remove("clearing"));

  if(bonusScore>0){
    score += bonusScore;
    toast(`Clear Bonus +${bonusScore}!`);
  }
  renderAll();
}

async function useBomb(){
  if(items.bomb<=0) return;
  items.bomb--;
  updateItemsUI();
  clearPick();
  await clearBoardEffectAndRefill(0);
  toast("üí• Boom Reset used!");
}

function useAllA(){
  if(items.allA<=0) return;
  items.allA--;
  updateItemsUI();
  clearPick();
  for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) grid[r][c]="A";
  renderAll();
  toast("üçè All letters ‚Üí A!");
}

function usePass(){
  if(items.pass<=0) return;
  items.pass--;
  updateItemsUI();
  clearPick();
  targetFilled = targetFilled.map(()=>true);
  renderAll();
  toast("ü™Ω Free Pass! Solved!");
  onTargetSolved();
}

/* =============================
   LEVEL / PROGRESS
============================= */
function updateProgressUI(){
  const need = requiredSolvesForLevel(level);
  const done = solvesThisLevel;
  elBarText.textContent = `${done}/${need}`;
  elBarFill.style.width = `${Math.min(100, (done/need)*100)}%`;
}

async function onTargetSolved(){
  solvesThisLevel += 1;
  // solve bonus
  score += 120 + level*10;

  // next target
  pickTargetWord();
  clearPick();

  const need = requiredSolvesForLevel(level);
  if(solvesThisLevel >= need){
    const oldLevel = level;
    level += 1;
    solvesThisLevel = 0;

    // level up clear + bonus
    const clearBonus = 300 + oldLevel*60;
    renderAll(); // show new level instantly
    await clearBoardEffectAndRefill(clearBonus);

    // give random item
    grantRandomItem();

    toast(`Level Up! Lv ${level}`);
  } else {
    renderAll();
    toast("Solved ‚úÖ");
  }
}

/* =============================
   INPUT (TAP BASED)
   - Solve: board -> slot
   - Merge: board -> same board
   - Storage:
       board -> empty storage (store, board refills)
       storage -> board (swap)
============================= */
function tapGridCell(r,c){
  const letter = grid[r][c];

  if(!pick){
    pick = {source:'grid', r, c, letter};
    renderAll();
    animateCell(r,c);
    return;
  }

  // storage selected -> swap
  if(pick.source === "storage"){
    const idx = pick.idx;
    const tmp = grid[r][c];
    grid[r][c] = storage[idx];
    storage[idx] = tmp;
    score += 2;
    clearPick();
    renderAll();
    toast("Swapped!");
    return;
  }

  // grid selected
  if(pick.source === "grid"){
    const a = pick;

    // same cell -> unselect
    if(a.r===r && a.c===c){
      clearPick();
      renderAll();
      return;
    }

    // merge if same letter
    if(a.letter === letter){
      grid[r][c] = nextLetter(letter);
      refillCell(a.r, a.c);
      score += 12;
      clearPick();
      renderAll();
      animateCell(r,c);
      toast("Merged!");
      return;
    }

    // otherwise move selection
    pick = {source:'grid', r, c, letter};
    renderAll();
    animateCell(r,c);
  }
}

function tapTargetSlot(i, slotEl){
  if(!pick || pick.source !== "grid"){
    pulseWrong(slotEl);
    toast("Tap a board letter first üôÇ");
    return;
  }
  if(targetFilled[i]){
    pulseWrong(slotEl);
    toast("Already filled üôÇ");
    return;
  }

  const need = targetWord[i];
  if(pick.letter !== need){
    pulseWrong(slotEl);
    toast("Wrong letter üòÖ");
    return;
  }

  // fill
  targetFilled[i] = true;
  refillCell(pick.r, pick.c);
  score += 25;
  clearPick();

  if(targetFilled.every(Boolean)){
    toast("Perfect! üéâ");
    onTargetSolved();
  } else {
    renderAll();
    toast("Nice!");
  }
}

function tapStorageSlot(i){
  const has = storage[i];

  if(!pick){
    if(has){
      pick = {source:'storage', idx:i, letter: has};
      renderAll();
      toast("Storage selected");
    } else {
      toast("Empty storage");
    }
    return;
  }

  // board selected -> store into empty slot
  if(pick.source === "grid"){
    if(has){
      toast("Storage not empty üòÖ");
      return;
    }
    storage[i] = pick.letter;
    refillCell(pick.r, pick.c);
    score += 1;
    clearPick();
    renderAll();
    toast("Stored!");
    return;
  }

  // storage selected -> switch selection / clear
  if(pick.source === "storage"){
    if(!has){
      clearPick();
      renderAll();
      return;
    }
    pick = {source:'storage', idx:i, letter: has};
    renderAll();
  }
}

/* =============================
   RENDER
============================= */
function renderTop(){
  elLevel.textContent = String(level);
  elScore.textContent = String(score);

  const p = levelParams(level);
  const mx = targetWord ? wordMaxLetterIndex(targetWord) : 0;
  const mxChar = LETTERS[mx] || "A";
  const alpha = rarityAlphaForLevel(level).toFixed(2);

  const wordsInfo = BANK_READY ? `Words: ${WORD_BANK.length.toLocaleString()}` : "Words: loading‚Ä¶";
  elTargetHint.textContent =
    `Lv window: length ${p.lenMin}-${p.lenMax}, letters ‚â§ ${p.cap} (target max ${mxChar}). ${wordsInfo}`;

  elDifficultyHint.textContent =
    `Difficulty rises fairly. Late letters stay rare (Œ±=${alpha}). Level-ups give a random item.`;

  updateProgressUI();
}

function renderTarget(){
  elTargetSlots.innerHTML = "";
  const armed = (pick && pick.source === "grid");
  const pickedLetter = armed ? pick.letter : null;

  for(let i=0;i<targetWord.length;i++){
    const need = targetWord[i];
    const slot = document.createElement("div");
    slot.className = "slot";
    slot.textContent = need;

    if(targetFilled[i]) slot.classList.add("filled");
    if(armed && !targetFilled[i]) slot.classList.add("armed");
    if(armed && !targetFilled[i] && pickedLetter === need) slot.classList.add("match");

    slot.addEventListener("click", ()=>tapTargetSlot(i, slot));
    elTargetSlots.appendChild(slot);
  }
}

function renderGrid(){
  elGrid.innerHTML = "";
  const armed = (pick && pick.source === "grid");
  const pickedLetter = armed ? pick.letter : null;

  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      const d = document.createElement("div");
      d.className = "cell";
      d.id = `cell-${r}-${c}`;
      d.textContent = grid[r][c];

      if(armed && pick.r===r && pick.c===c){
        d.classList.add("selected");
      } else if(armed && grid[r][c] === pickedLetter){
        d.classList.add("matchHint");
      }

      d.addEventListener("click", ()=>tapGridCell(r,c));
      elGrid.appendChild(d);
    }
  }
}

function renderStorage(){
  elStorageSlots.innerHTML = "";
  for(let i=0;i<5;i++){
    const s = document.createElement("div");
    s.className = "stash";
    if(storage[i] != null) s.classList.add("filled");
    s.textContent = storage[i] ? storage[i] : "‚Ä¢";

    if(pick && pick.source==="storage" && pick.idx===i) s.classList.add("selected");

    s.addEventListener("click", ()=>tapStorageSlot(i));
    elStorageSlots.appendChild(s);
  }
}

function renderAll(){
  renderTop();
  renderTarget();
  renderGrid();
  renderStorage();
  updateSelectionChip();
  updateItemsUI();
}

/* =============================
   EVENTS
============================= */
document.getElementById("resetBtn").addEventListener("click", resetGame);
elItemBomb.addEventListener("click", ()=>{ if(items.bomb>0) useBomb(); });
elItemAllA.addEventListener("click", ()=>{ if(items.allA>0) useAllA(); });
elItemPass.addEventListener("click", ()=>{ if(items.pass>0) usePass(); });

window.addEventListener("resize", ()=>{
  autoFitCellSize();
});

/* =============================
   INIT
============================= */
function resetGame(){
  level = 1;
  score = 0;
  solvesThisLevel = 0;
  storage = Array(5).fill(null);
  clearPick();

  items.bomb = 0;
  items.allA = 0;
  items.pass = 0;

  fillBoardFull();
  pickTargetWord();
  renderAll();
  autoFitCellSize();
}

(async function start(){
  fillBoardFull();
  autoFitCellSize();
  renderAll();

  // Load large word bank
  await loadWordBank();

  // Once bank is ready, pick a valid target using bank + no-repeat
  pickTargetWord();
  renderAll();

  toast("Welcome to FOR EILEEN ‚ú®");
})();
</script>
</body>
</html>
