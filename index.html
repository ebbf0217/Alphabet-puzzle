<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
<title>FOR EILEEN</title>
<style>
  :root{
    /* Bold primary colors (close to ‚Äúsolid‚Äù colors) */
    --G:#00C853;     /* vivid green */
    --G2:#00A846;    /* darker green */
    --O:#FF6D00;     /* vivid orange */
    --O2:#FF4D00;    /* deeper orange */
    --Y:#FFD600;     /* tiny accent */

    --ink:#10231B;
    --muted:#1C4B3A;

    --bg:#F7FFF9;

    --card:#FFFFFF;
    --line:#0C2B20;
    --shadow: 0 10px 0 rgba(12,43,32,.18);

    --danger:#FF2D2D;

    /* layout vars (JS updates) */
    --appH: 100vh;
    --cell: 52px;
    --gap: 8px;
  }

  *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
  html,body{ height:100%; }
  body{
    margin:0;
    background: radial-gradient(900px 450px at 15% 5%, rgba(0,200,83,.20), transparent 60%),
                radial-gradient(900px 450px at 85% 15%, rgba(255,109,0,.22), transparent 60%),
                var(--bg);
    font-family: ui-rounded, system-ui, -apple-system, "Segoe UI", sans-serif;
    color:var(--ink);
    height: var(--appH);
    overflow:hidden; /* we will fit without scroll */
    display:flex;
    justify-content:center;
  }

  .app{
    width:min(520px, 100vw);
    height: var(--appH);
    padding: 10px 10px calc(10px + env(safe-area-inset-bottom));
    display:flex;
    flex-direction:column;
    gap:10px;
    overflow:hidden;
  }

  /* Sticker Card */
  .card{
    background: var(--card);
    border: 3px solid var(--line);
    border-radius: 22px;
    box-shadow: var(--shadow);
    overflow:hidden;
  }

  /* TOP BAR */
  .top{
    padding:10px 10px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    flex: 0 0 auto;
  }
  .brand{
    display:flex;
    align-items:center;
    gap:10px;
    min-width:0;
  }
  .logo{
    width:38px;
    height:38px;
    border-radius:16px;
    border:3px solid var(--line);
    background:
      conic-gradient(from 180deg, var(--G), var(--O), var(--Y), var(--G2), var(--O2), var(--G));
    box-shadow: 0 8px 0 rgba(12,43,32,.12);
    flex:0 0 auto;
  }
  .brandText{ min-width:0; }
  .brandText .title{
    margin:0;
    font-weight:1000;
    letter-spacing:.6px;
    font-size:14px;
    line-height:1.0;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .brandText .sub{
    margin:3px 0 0;
    font-size:11px;
    font-weight:900;
    color: rgba(16,35,27,.70);
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }

  .stats{
    display:flex;
    align-items:center;
    gap:8px;
    flex:0 0 auto;
  }
  .pill{
    border:3px solid var(--line);
    border-radius:999px;
    padding:7px 10px;
    font-weight:1000;
    font-size:12px;
    background: #fff;
    box-shadow: 0 6px 0 rgba(12,43,32,.10);
    white-space:nowrap;
  }
  .reset{
    border:3px solid var(--line);
    background: linear-gradient(135deg, var(--G), var(--O));
    color:#fff;
    font-weight:1100;
    border-radius:16px;
    padding:7px 10px;
    box-shadow: 0 7px 0 rgba(12,43,32,.12);
    cursor:pointer;
  }
  .reset:active{ transform: translateY(1px); box-shadow: 0 6px 0 rgba(12,43,32,.12); }

  /* TARGET BAR */
  .target{
    padding:10px 10px 10px;
    flex: 0 0 auto;
  }
  .targetTop{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
  }
  .targetTop .label{
    font-weight:1100;
    font-size:13px;
  }
  .targetTop .how{
    font-weight:1000;
    font-size:11px;
    color: rgba(16,35,27,.65);
  }

  .slotsRow{
    margin-top:8px;
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    align-items:center;
  }
  .slot{
    width: calc(var(--cell) * .88);
    height: calc(var(--cell) * .88);
    border-radius:18px;
    border: 3px dashed rgba(12,43,32,.35);
    background: linear-gradient(135deg, rgba(0,200,83,.18), rgba(255,109,0,.18));
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:22px;
    font-weight:1100;
    color: rgba(16,35,27,.22);
    user-select:none;
    cursor:pointer;
    box-shadow: 0 7px 0 rgba(12,43,32,.08);
    transition: transform .08s ease;
  }
  .slot:active{ transform: translateY(1px); }

  .slot.filled{
    border-style:solid;
    border-color: rgba(0,200,83,.75);
    background: linear-gradient(135deg, rgba(0,200,83,.30), rgba(255,214,0,.30));
    color: rgba(16,35,27,.95);
  }
  .slot.armed{
    border-color: rgba(255,109,0,.75);
  }
  .slot.match{
    border-style:solid;
    border-color: rgba(0,200,83,.85);
    box-shadow: 0 7px 0 rgba(0,200,83,.10);
  }
  .slot.wrong{
    border-style:solid;
    border-color: rgba(255,45,45,.80);
    background: rgba(255,45,45,.10);
    animation: shake .22s ease-in-out;
  }
  @keyframes shake{
    0%{ transform: translateX(0); }
    25%{ transform: translateX(-6px); }
    50%{ transform: translateX(6px); }
    75%{ transform: translateX(-4px); }
    100%{ transform: translateX(0); }
  }

  .progressWrap{
    margin-top:8px;
    display:flex;
    align-items:center;
    gap:10px;
  }
  .bar{
    flex:1;
    height:14px;
    border-radius:999px;
    border:3px solid var(--line);
    background:#fff;
    overflow:hidden;
    box-shadow: 0 6px 0 rgba(12,43,32,.08);
  }
  .barFill{
    height:100%;
    width:0%;
    background: linear-gradient(90deg, var(--G), var(--O));
    border-radius:999px;
    transition: width .18s ease;
  }
  .barText{
    font-weight:1100;
    font-size:12px;
    white-space:nowrap;
  }

  .selection{
    margin-top:8px;
    border:3px solid var(--line);
    border-radius:18px;
    background: #fff;
    box-shadow: 0 7px 0 rgba(12,43,32,.08);
    padding:8px 10px;
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:10px;
  }
  .selLeft{
    min-width:0;
  }
  .selLeft .t{
    font-size:11px;
    font-weight:1100;
  }
  .selLeft .g{
    font-size:11px;
    font-weight:1000;
    color: rgba(16,35,27,.65);
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .selBig{
    font-size:18px;
    font-weight:1200;
  }

  /* GRID (main area MUST be visible) */
  .gridCard{
    padding:10px;
    flex: 1 1 auto;
    min-height: 0;
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  .tinyLine{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    font-size:11px;
    font-weight:1000;
    color: rgba(16,35,27,.70);
  }
  .loading{
    display:none;
    align-items:center;
    gap:6px;
    font-weight:1100;
    color: rgba(16,35,27,.70);
  }
  .spinner{
    width:12px; height:12px;
    border-radius:50%;
    border:3px solid rgba(12,43,32,.16);
    border-top-color: rgba(255,109,0,.90);
    animation: spin .7s linear infinite;
  }
  @keyframes spin { to{ transform: rotate(360deg);} }

  .gridWrap{
    flex: 1 1 auto;
    min-height: 0;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .grid{
    display:grid;
    grid-template-columns: repeat(5, var(--cell));
    grid-template-rows: repeat(5, var(--cell));
    gap: var(--gap);
  }
  .cell{
    width: var(--cell);
    height: var(--cell);
    border-radius: 22px;
    border:3px solid var(--line);
    background: #fff;
    box-shadow: 0 9px 0 rgba(12,43,32,.10);
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:22px;
    font-weight:1200;
    cursor:pointer;
    user-select:none;
    transition: transform .08s ease, outline .08s ease, opacity .18s ease;
  }
  .cell:active{ transform: translateY(1px); box-shadow: 0 8px 0 rgba(12,43,32,.10); }
  .cell.selected{
    outline: 5px solid rgba(255,109,0,.55);
    outline-offset: 2px;
  }
  .cell.matchHint{
    outline: 5px solid rgba(0,200,83,.22);
    outline-offset: 2px;
  }
  .cell.pop{ animation: pop .16s ease-in-out; }
  @keyframes pop{
    0%{ transform: scale(.98); }
    60%{ transform: scale(1.06); }
    100%{ transform: scale(1); }
  }

  /* Level-up clear effect */
  .cell.clearing{
    animation: clearDrop .35s ease forwards;
  }
  @keyframes clearDrop{
    0%{ opacity:1; transform: translateY(0) scale(1); }
    70%{ opacity:.85; transform: translateY(14px) scale(.98); }
    100%{ opacity:0; transform: translateY(40px) scale(.94); }
  }

  /* BOTTOM BAR */
  .bottom{
    padding:10px;
    flex: 0 0 auto;
  }
  .bottomRow{
    display:flex;
    gap:10px;
    align-items:flex-start;
    justify-content:space-between;
  }

  .block{
    flex:1;
    min-width:0;
  }
  .blockTitle{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:8px;
    margin-bottom:8px;
    font-size:11px;
    font-weight:1200;
    color: rgba(16,35,27,.90);
  }
  .blockTitle span{
    color: rgba(16,35,27,.60);
    font-weight:1100;
    white-space:nowrap;
  }

  /* Storage tiny */
  .storageRow{
    display:flex;
    gap:6px;
    align-items:center;
  }
  .stash{
    width:34px; height:34px;
    border-radius:16px;
    border:3px dashed rgba(12,43,32,.35);
    background:#fff;
    box-shadow: 0 6px 0 rgba(12,43,32,.08);
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:1200;
    font-size:15px;
    cursor:pointer;
    user-select:none;
  }
  .stash.filled{
    border-style:solid;
    background: linear-gradient(135deg, rgba(0,200,83,.16), rgba(255,109,0,.16));
  }
  .stash.selected{
    outline: 5px solid rgba(0,200,83,.35);
    outline-offset: 2px;
  }
  .stash:active{ transform: translateY(1px); box-shadow: 0 5px 0 rgba(12,43,32,.08); }

  /* Items */
  .itemsRow{
    display:flex;
    gap:8px;
    align-items:center;
    justify-content:flex-end;
  }
  .itemBtn{
    position:relative;
    width:42px; height:42px;
    border-radius:18px;
    border:3px solid var(--line);
    background: linear-gradient(135deg, rgba(255,109,0,.18), rgba(0,200,83,.18));
    box-shadow: 0 8px 0 rgba(12,43,32,.10);
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    user-select:none;
  }
  .itemBtn:active{ transform: translateY(1px); box-shadow: 0 7px 0 rgba(12,43,32,.10); }
  .itemBtn.disabled{ opacity:.45; filter: grayscale(.15); }
  .itemIcon{ font-size:18px; }
  .badge{
    position:absolute;
    right:-7px;
    top:-7px;
    min-width:18px;
    height:18px;
    padding:0 5px;
    border-radius:999px;
    background: linear-gradient(135deg, var(--G), var(--O));
    border:3px solid var(--line);
    color:#fff;
    font-size:11px;
    font-weight:1200;
    display:flex;
    align-items:center;
    justify-content:center;
  }

  .toast{
    position:fixed;
    left:50%;
    transform: translateX(-50%);
    bottom: calc(10px + env(safe-area-inset-bottom));
    background:#fff;
    border:3px solid var(--line);
    box-shadow: 0 10px 0 rgba(12,43,32,.12);
    padding:10px 12px;
    border-radius:999px;
    font-weight:1200;
    font-size:13px;
    opacity:0;
    pointer-events:none;
    transition: opacity .18s ease, transform .18s ease;
    z-index:9999;
  }
  .toast.show{
    opacity:1;
    transform: translateX(-50%) translateY(-2px);
  }

  /* Small phones: tighten a bit */
  @media (max-width: 390px){
    .pill{ padding:6px 9px; font-size:11px; }
    .reset{ padding:6px 9px; }
    .stash{ width:32px; height:32px; }
    .itemBtn{ width:40px; height:40px; }
  }
</style>
</head>
<body>
  <div class="app" id="app">

    <!-- TOP -->
    <div class="card top" id="topCard">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div class="brandText">
          <div class="title">FOR EILEEN</div>
          <div class="sub">Tap to merge ¬∑ Tap to solve</div>
        </div>
      </div>
      <div class="stats">
        <div class="pill">Lv <span id="level">1</span></div>
        <div class="pill">Score <span id="score">0</span></div>
        <button class="reset" id="resetBtn">Reset</button>
      </div>
    </div>

    <!-- TARGET -->
    <div class="card target" id="targetCard">
      <div class="targetTop">
        <div class="label">Target</div>
        <div class="how">Tap board ‚Üí tap slot</div>
      </div>

      <div class="slotsRow" id="targetSlots"></div>

      <div class="progressWrap">
        <div class="bar"><div class="barFill" id="barFill"></div></div>
        <div class="barText" id="barText">0/1</div>
      </div>

      <div class="selection">
        <div class="selLeft">
          <div class="t">Selected</div>
          <div class="g" id="selText">Nothing</div>
        </div>
        <div class="selBig" id="selBig">‚Äî</div>
      </div>
    </div>

    <!-- GRID -->
    <div class="card gridCard" id="gridCard">
      <div class="tinyLine">
        <div>Merge: tap same letters (A+A‚ÜíB)</div>
        <div class="loading" id="loadingPill"><span class="spinner"></span>Words</div>
      </div>
      <div class="gridWrap">
        <div class="grid" id="grid"></div>
      </div>
    </div>

    <!-- BOTTOM -->
    <div class="card bottom" id="bottomCard">
      <div class="bottomRow">
        <div class="block">
          <div class="blockTitle">Storage <span>(board ‚Üí empty)</span></div>
          <div class="storageRow" id="storageSlots"></div>
        </div>
        <div class="block" style="flex:0 0 auto;">
          <div class="blockTitle">Items <span>(tap)</span></div>
          <div class="itemsRow">
            <div class="itemBtn" id="itemBomb" title="Boom Reset: clear & refill letters">
              <div class="itemIcon">üí•</div><div class="badge" id="bombCount">0</div>
            </div>
            <div class="itemBtn" id="itemAllA" title="All A: turn all letters into A">
              <div class="itemIcon">üçè</div><div class="badge" id="allACount">0</div>
            </div>
            <div class="itemBtn" id="itemPass" title="Free Pass: solve instantly">
              <div class="itemIcon">ü™Ω</div><div class="badge" id="passCount">0</div>
            </div>
          </div>
        </div>
      </div>
    </div>

  </div>

  <div class="toast" id="toast">Hi!</div>

<script>
/* =============================
   FINAL: Kakao in-app browser safe layout
   - Uses visualViewport height to avoid URL bar cropping
   - Calculates cell size from remaining space => grid always visible
   - Keeps all gameplay features intact
============================= */

const SIZE = 5;
const LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");

/* DOM */
const app = document.getElementById("app");
const topCard = document.getElementById("topCard");
const targetCard = document.getElementById("targetCard");
const gridCard = document.getElementById("gridCard");
const bottomCard = document.getElementById("bottomCard");

const elLevel = document.getElementById("level");
const elScore = document.getElementById("score");
const elGrid = document.getElementById("grid");
const elTargetSlots = document.getElementById("targetSlots");
const elBarFill = document.getElementById("barFill");
const elBarText = document.getElementById("barText");
const elSelText = document.getElementById("selText");
const elSelBig = document.getElementById("selBig");
const elStorageSlots = document.getElementById("storageSlots");
const loadingPill = document.getElementById("loadingPill");

const elBombCount = document.getElementById("bombCount");
const elAllACount = document.getElementById("allACount");
const elPassCount = document.getElementById("passCount");

const itemBomb = document.getElementById("itemBomb");
const itemAllA = document.getElementById("itemAllA");
const itemPass = document.getElementById("itemPass");

/* Game state */
let level = 1;
let score = 0;

let grid = [];
let storage = Array(5).fill(null);

let targetWord = "";
let targetFilled = [];

let pick = null; // {source:'grid', r,c, letter} OR {source:'storage', idx, letter}

/* level progress: arithmetic 1,2,3... solves */
let solvesThisLevel = 0;
const requiredSolvesForLevel = (lv) => lv;

/* Items inventory */
const items = { bomb:0, allA:0, pass:0 };

/* Word bank + no repeats */
let WORD_BANK = [];
let BANK_READY = false;
const USED_KEY = "for_eileen_used_words_v2";
let USED_SET = new Set();

const FALLBACK_WORDS = [
  "BAD","BAG","BAR","BAT","CAB","CAN","CAP","CAR","CAT","DAD","DAY","EAR","EAT","FAR","FAT","GAS","GAP","HAT","HAD",
  "BARK","BAND","BANK","BEAR","BEAT","BELL","BEND","BIRD","BITE","BOAT","BOOK","CAMP","CART","CAVE","CODE","COOL","COLD",
  "DARK","DEAL","DEEP","DICE","DISH","ECHO","FIRE","FISH","FORK","GAME","GATE","GOLD","GOOD","HOME",
  "APPLE","BRICK","CLOUD","DANCE","GLASS","GREEN","HONEY","HOUSE","LIGHT","MOUSE","MUSIC","NIGHT","OCEAN","PLANE",
  "PLANT","POINT","POWER","RIVER","SHEEP","SHARK","SNAKE","SUGAR","TABLE","TRAIN",
  "JAZZ","QUIZ","JINX","VEX","WAX","YAWN","ZANY","ZOOM","ZEST","ZERO","ZEBRA"
];

/* =============================
   UI helpers
============================= */
function toast(msg){
  const t = document.getElementById("toast");
  t.textContent = msg;
  t.classList.add("show");
  setTimeout(()=>t.classList.remove("show"), 900);
}
function animateCell(r,c){
  const el = document.getElementById(`cell-${r}-${c}`);
  if(!el) return;
  el.classList.remove("pop");
  void el.offsetWidth;
  el.classList.add("pop");
}
function pulseWrong(slotEl){
  slotEl.classList.remove("wrong");
  void slotEl.offsetWidth;
  slotEl.classList.add("wrong");
  setTimeout(()=>slotEl.classList.remove("wrong"), 260);
}
function clearPick(){ pick = null; }
function updateSelectionChip(){
  if(!pick){
    elSelText.textContent = "Nothing";
    elSelBig.textContent = "‚Äî";
    return;
  }
  if(pick.source === "grid"){
    elSelText.textContent = "Board letter";
    elSelBig.textContent = pick.letter;
  } else {
    elSelText.textContent = "Storage letter";
    elSelBig.textContent = pick.letter;
  }
}

/* =============================
   Layout: visualViewport-safe height + cell sizing
   This is the key fix for Kakao in-app browser.
============================= */
function setAppHeightFromViewport(){
  const vv = window.visualViewport;
  const h = vv ? vv.height : window.innerHeight;
  document.documentElement.style.setProperty("--appH", `${Math.round(h)}px`);
}

function computeCellSize(){
  // available width for 5 cells + gaps inside gridCard
  const pad = 10; // gridCard padding
  const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--gap")) || 8;

  const vv = window.visualViewport;
  const appH = vv ? vv.height : window.innerHeight;

  // measure fixed cards
  const topH = topCard.getBoundingClientRect().height;
  const targetH = targetCard.getBoundingClientRect().height;
  const bottomH = bottomCard.getBoundingClientRect().height;

  // app padding + gaps between cards
  const appStyle = getComputedStyle(app);
  const pt = parseFloat(appStyle.paddingTop) || 0;
  const pb = parseFloat(appStyle.paddingBottom) || 0;
  const gapY = 10; // same as .app gap

  // total vertical used excluding gridCard
  // Note: gridCard itself includes padding; we are setting cell size to fit inside it.
  const used = pt + pb + topH + targetH + bottomH + gapY*3; // 4 cards => 3 gaps
  let availableForGridCard = appH - used;

  // guard
  availableForGridCard = Math.max(160, availableForGridCard);

  // Inside gridCard: tinyLine + padding top/bottom + gridWrap
  // We'll approximate tinyLine height ~ 22, plus internal gaps/padding.
  const tinyLineH = 26;
  const innerVertical = pad*2 + tinyLineH + 8; // padding + title + gap
  let gridAreaH = Math.max(120, availableForGridCard - innerVertical);

  // cellSize based on height: 5 cells + 4 gaps must fit in gridAreaH
  const cellFromH = Math.floor((gridAreaH - gap*4) / 5);

  // width constraint
  const appW = app.getBoundingClientRect().width;
  const innerW = appW - 20; // app horizontal padding 10+10
  const gridCardInnerW = innerW - pad*2;
  const cellFromW = Math.floor((gridCardInnerW - gap*4) / 5);

  // choose smallest to fit both
  let cell = Math.min(cellFromH, cellFromW);

  // keep touch-friendly minimum, but if too small, still show the grid
  cell = Math.max(40, Math.min(66, cell));

  document.documentElement.style.setProperty("--cell", `${cell}px`);

  // adjust font size slightly for small cell
  const base = cell >= 56 ? 22 : (cell >= 48 ? 20 : 18);
  document.querySelectorAll(".cell").forEach(el => el.style.fontSize = `${base}px`);
}

function relayout(){
  setAppHeightFromViewport();
  // compute after a tick so DOM has updated sizes
  requestAnimationFrame(() => {
    computeCellSize();
  });
}

/* Listen viewport changes (URL bar show/hide) */
if (window.visualViewport) {
  visualViewport.addEventListener("resize", relayout);
  visualViewport.addEventListener("scroll", relayout);
}
window.addEventListener("resize", relayout);
window.addEventListener("orientationchange", relayout);

/* =============================
   Letters rarity + merge rules
============================= */
function rarityAlphaForLevel(lv){
  return Math.min(3.0, 1.15 + lv * 0.10);
}
function randomLetterByLevel(lv){
  const alpha = rarityAlphaForLevel(lv);
  let sum = 0;
  const weights = [];
  for(let i=0;i<LETTERS.length;i++){
    const w = 1 / Math.pow(i+1, alpha);
    weights.push(w);
    sum += w;
  }
  let r = Math.random() * sum;
  for(let i=0;i<weights.length;i++){
    r -= weights[i];
    if(r <= 0) return LETTERS[i];
  }
  return "A";
}
function nextLetter(ch){
  const i = LETTERS.indexOf(ch);
  return (i >= 0 && i < 25) ? LETTERS[i+1] : "Z";
}

/* =============================
   Difficulty window (fair)
============================= */
function letterIndex(ch){ return LETTERS.indexOf(ch); }
function wordMaxLetterIndex(word){
  let m=0;
  for(const ch of word) m = Math.max(m, letterIndex(ch));
  return m;
}
function levelParams(lv){
  if(lv <= 2)  return {lenMin:3, lenMax:3, cap:"H"};
  if(lv <= 5)  return {lenMin:3, lenMax:4, cap:"K"};
  if(lv <= 9)  return {lenMin:4, lenMax:4, cap:"N"};
  if(lv <= 14) return {lenMin:4, lenMax:5, cap:"R"};
  if(lv <= 20) return {lenMin:5, lenMax:6, cap:"V"};
  return          {lenMin:5, lenMax:7, cap:"Z"};
}

/* =============================
   Word bank loading (big) + no repeat
============================= */
function loadUsedSet(){
  try{
    const raw = localStorage.getItem(USED_KEY);
    if(!raw) return;
    const arr = JSON.parse(raw);
    if(Array.isArray(arr)) USED_SET = new Set(arr);
  } catch {}
}
function saveUsedSet(){
  try{
    const arr = Array.from(USED_SET);
    const trimmed = arr.length > 25000 ? arr.slice(arr.length - 25000) : arr;
    localStorage.setItem(USED_KEY, JSON.stringify(trimmed));
  } catch {}
}

async function loadWordBank(){
  loadUsedSet();
  loadingPill.style.display = "inline-flex";
  const URL = "https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt";

  try{
    const res = await fetch(URL, {cache:"force-cache"});
    if(!res.ok) throw new Error("fetch fail");
    const text = await res.text();
    const lines = text.split(/\r?\n/);
    const bank = [];
    for(const w of lines){
      if(!w) continue;
      const L = w.length;
      if(L < 3 || L > 7) continue;
      let ok = true;
      for(let i=0;i<L;i++){
        const c = w.charCodeAt(i);
        if(c < 97 || c > 122){ ok=false; break; }
      }
      if(!ok) continue;
      bank.push(w.toUpperCase());
      if(bank.length >= 30000) break;
    }
    WORD_BANK = bank.length ? bank : FALLBACK_WORDS.slice();
    BANK_READY = true;
    toast(`Words: ${WORD_BANK.length.toLocaleString()}`);
  } catch {
    WORD_BANK = FALLBACK_WORDS.slice();
    BANK_READY = true;
    toast("Word list offline ‚Üí fallback");
  } finally {
    loadingPill.style.display = "none";
  }
}

function pickTargetWord(){
  if(!BANK_READY || !WORD_BANK.length){
    targetWord = "CAT";
    targetFilled = Array.from({length: targetWord.length}, () => false);
    return;
  }
  const p = levelParams(level);
  const capIdx = letterIndex(p.cap);

  const strictOk = (w) =>
    w.length >= p.lenMin && w.length <= p.lenMax &&
    wordMaxLetterIndex(w) <= capIdx;

  let chosen = null;

  // strict tries
  for(let t=0; t<900; t++){
    const w = WORD_BANK[(Math.random()*WORD_BANK.length)|0];
    if(!strictOk(w)) continue;
    if(USED_SET.has(w)) continue;
    chosen = w; break;
  }

  // relax: length only
  if(!chosen){
    for(let t=0; t<1200; t++){
      const w = WORD_BANK[(Math.random()*WORD_BANK.length)|0];
      if(w.length < p.lenMin || w.length > p.lenMax) continue;
      if(USED_SET.has(w)) continue;
      chosen = w; break;
    }
  }

  // exhausted
  if(!chosen){
    USED_SET.clear();
    saveUsedSet();
    chosen = WORD_BANK[(Math.random()*WORD_BANK.length)|0];
  }

  targetWord = chosen;
  targetFilled = Array.from({length: targetWord.length}, () => false);

  USED_SET.add(targetWord);
  saveUsedSet();
}

/* =============================
   Board
============================= */
function fillBoardFull(){
  grid = Array.from({length: SIZE}, () =>
    Array.from({length: SIZE}, () => randomLetterByLevel(level))
  );
}
function refillCell(r,c){
  grid[r][c] = randomLetterByLevel(level);
}

/* Level-up clear effect */
async function clearBoardEffectAndRefill(bonusScore=0){
  const nodes = [];
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      const el = document.getElementById(`cell-${r}-${c}`);
      if(el) nodes.push({el, r, c});
    }
  }
  nodes.sort((a,b)=>(b.r-a.r)||(a.c-b.c));
  nodes.forEach((n, idx)=> setTimeout(()=>n.el.classList.add("clearing"), idx*16));
  await new Promise(res=> setTimeout(res, nodes.length*16 + 380));

  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      grid[r][c] = randomLetterByLevel(level);
    }
  }
  nodes.forEach(n=>n.el.classList.remove("clearing"));

  if(bonusScore>0){
    score += bonusScore;
    toast(`Clear Bonus +${bonusScore}!`);
  }
  renderAll();
}

/* Items */
function updateItemsUI(){
  elBombCount.textContent = String(items.bomb);
  elAllACount.textContent = String(items.allA);
  elPassCount.textContent = String(items.pass);

  itemBomb.classList.toggle("disabled", items.bomb <= 0);
  itemAllA.classList.toggle("disabled", items.allA <= 0);
  itemPass.classList.toggle("disabled", items.pass <= 0);
}
function grantRandomItem(){
  const pool = ["bomb","allA","pass"];
  const got = pool[(Math.random()*pool.length)|0];
  items[got] += 1;
  updateItemsUI();
  if(got==="bomb") toast("Item +1 üí•");
  if(got==="allA") toast("Item +1 üçè");
  if(got==="pass") toast("Item +1 ü™Ω");
}
async function useBomb(){
  if(items.bomb<=0) return;
  items.bomb--;
  updateItemsUI();
  clearPick();
  await clearBoardEffectAndRefill(0);
  toast("üí• Boom Reset!");
}
function useAllA(){
  if(items.allA<=0) return;
  items.allA--;
  updateItemsUI();
  clearPick();
  for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) grid[r][c]="A";
  renderAll();
  toast("üçè All A!");
}
function usePass(){
  if(items.pass<=0) return;
  items.pass--;
  updateItemsUI();
  clearPick();
  targetFilled = targetFilled.map(()=>true);
  renderAll();
  toast("ü™Ω Free Pass!");
  onTargetSolved();
}

/* Progress */
function updateProgressUI(){
  const need = requiredSolvesForLevel(level);
  elBarText.textContent = `${solvesThisLevel}/${need}`;
  elBarFill.style.width = `${Math.min(100, (solvesThisLevel/need)*100)}%`;
}
async function onTargetSolved(){
  solvesThisLevel += 1;
  score += 120 + level*10;

  pickTargetWord();
  clearPick();

  const need = requiredSolvesForLevel(level);
  if(solvesThisLevel >= need){
    const old = level;
    level += 1;
    solvesThisLevel = 0;

    renderAll(); // show new level immediately
    await clearBoardEffectAndRefill(300 + old*60);
    grantRandomItem();
    toast(`Level Up! Lv ${level}`);
  } else {
    renderAll();
    toast("Solved ‚úÖ");
  }
}

/* =============================
   INPUT (tap-tap, storage, merge)
============================= */
function tapGridCell(r,c){
  const letter = grid[r][c];

  if(!pick){
    pick = {source:"grid", r, c, letter};
    renderAll();
    animateCell(r,c);
    return;
  }

  // storage selected -> swap
  if(pick.source === "storage"){
    const idx = pick.idx;
    const tmp = grid[r][c];
    grid[r][c] = storage[idx];
    storage[idx] = tmp;
    score += 2;
    clearPick();
    renderAll();
    toast("Swapped!");
    return;
  }

  // grid selected
  if(pick.source === "grid"){
    const a = pick;

    if(a.r===r && a.c===c){
      clearPick();
      renderAll();
      return;
    }

    // merge
    if(a.letter === letter){
      grid[r][c] = nextLetter(letter);
      refillCell(a.r, a.c);
      score += 12;
      clearPick();
      renderAll();
      animateCell(r,c);
      toast("Merged!");
      return;
    }

    // change selection
    pick = {source:"grid", r, c, letter};
    renderAll();
    animateCell(r,c);
  }
}

function tapTargetSlot(i, slotEl){
  if(!pick || pick.source !== "grid"){
    pulseWrong(slotEl);
    toast("Tap a board letter üôÇ");
    return;
  }
  if(targetFilled[i]){
    pulseWrong(slotEl);
    toast("Already filled");
    return;
  }
  const need = targetWord[i];
  if(pick.letter !== need){
    pulseWrong(slotEl);
    toast("Wrong letter üòÖ");
    return;
  }

  targetFilled[i] = true;
  refillCell(pick.r, pick.c);
  score += 25;
  clearPick();

  if(targetFilled.every(Boolean)){
    toast("Perfect! üéâ");
    onTargetSolved();
  } else {
    renderAll();
    toast("Nice!");
  }
}

function tapStorageSlot(i){
  const has = storage[i];

  if(!pick){
    if(has){
      pick = {source:"storage", idx:i, letter: has};
      renderAll();
      toast("Storage selected");
    } else {
      toast("Empty");
    }
    return;
  }

  // board selected -> store into empty
  if(pick.source === "grid"){
    if(has){
      toast("Not empty üòÖ");
      return;
    }
    storage[i] = pick.letter;
    refillCell(pick.r, pick.c);
    score += 1;
    clearPick();
    renderAll();
    toast("Stored!");
    return;
  }

  // storage selected -> switch/clear
  if(pick.source === "storage"){
    if(!has){
      clearPick();
      renderAll();
      return;
    }
    pick = {source:"storage", idx:i, letter: has};
    renderAll();
  }
}

/* =============================
   RENDER
============================= */
function renderTop(){
  elLevel.textContent = String(level);
  elScore.textContent = String(score);
  updateProgressUI();
}

function renderTarget(){
  elTargetSlots.innerHTML = "";
  const armed = (pick && pick.source === "grid");
  const pickedLetter = armed ? pick.letter : null;

  for(let i=0;i<targetWord.length;i++){
    const need = targetWord[i];
    const slot = document.createElement("div");
    slot.className = "slot";
    slot.textContent = need;

    if(targetFilled[i]) slot.classList.add("filled");
    if(armed && !targetFilled[i]) slot.classList.add("armed");
    if(armed && !targetFilled[i] && pickedLetter === need) slot.classList.add("match");

    slot.addEventListener("click", ()=>tapTargetSlot(i, slot));
    elTargetSlots.appendChild(slot);
  }
}

function renderGrid(){
  elGrid.innerHTML = "";

  const armed = (pick && pick.source === "grid");
  const pickedLetter = armed ? pick.letter : null;

  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      const d = document.createElement("div");
      d.className = "cell";
      d.id = `cell-${r}-${c}`;
      d.textContent = grid[r][c];

      if(armed && pick.r===r && pick.c===c) d.classList.add("selected");
      else if(armed && grid[r][c] === pickedLetter) d.classList.add("matchHint");

      d.addEventListener("click", ()=>tapGridCell(r,c));
      elGrid.appendChild(d);
    }
  }
}

function renderStorage(){
  elStorageSlots.innerHTML = "";
  for(let i=0;i<5;i++){
    const s = document.createElement("div");
    s.className = "stash";
    if(storage[i] != null) s.classList.add("filled");
    s.textContent = storage[i] ? storage[i] : "‚Ä¢";
    if(pick && pick.source==="storage" && pick.idx===i) s.classList.add("selected");
    s.addEventListener("click", ()=>tapStorageSlot(i));
    elStorageSlots.appendChild(s);
  }
}

function renderAll(){
  renderTop();
  renderTarget();
  renderGrid();
  renderStorage();
  updateSelectionChip();
  updateItemsUI();

  // relayout AFTER render to guarantee grid shows
  relayout();
}

/* =============================
   INIT / RESET
============================= */
function resetGame(){
  level = 1;
  score = 0;
  solvesThisLevel = 0;
  storage = Array(5).fill(null);
  pick = null;

  items.bomb = 0; items.allA = 0; items.pass = 0;

  fillBoardFull();
  pickTargetWord();
  renderAll();
}

document.getElementById("resetBtn").addEventListener("click", resetGame);

itemBomb.addEventListener("click", ()=>{ if(items.bomb>0) useBomb(); });
itemAllA.addEventListener("click", ()=>{ if(items.allA>0) useAllA(); });
itemPass.addEventListener("click", ()=>{ if(items.pass>0) usePass(); });

/* Start */
(async function start(){
  // first layout
  setAppHeightFromViewport();
  fillBoardFull();

  // temporary target until words loaded
  targetWord = "CAT";
  targetFilled = [false,false,false];

  renderAll();

  await loadWordBank();
  pickTargetWord();
  renderAll();
  toast("Ready! ‚ú®");
})();
</script>
</body>
</html>
