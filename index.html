<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>FOR EILEEN</title>
<style>
  :root{
    /* Theme: Green + Orange */
    --bgA:#f3fff5;
    --bgB:#fff7ed;

    --card:rgba(255,255,255,.82);
    --line:rgba(17, 24, 39, .10);
    --shadow: 0 14px 34px rgba(16,24,40,.10);

    --ink:#183028;
    --muted:#5b7a6a;

    --green:#22c55e;
    --green2:#16a34a;
    --orange:#fb923c;
    --orange2:#f97316;
    --lemon:#fde047;

    --cell:#ffffff;
    --cell2:#f6fffa;
  }

  *{ box-sizing:border-box; }
  html,body{ height:100%; }
  body{
    margin:0;
    font-family: ui-rounded, system-ui, -apple-system, "Segoe UI", sans-serif;
    color:var(--ink);
    background:
      radial-gradient(900px 500px at 18% 10%, rgba(34,197,94,.20) 0%, transparent 62%),
      radial-gradient(900px 600px at 90% 18%, rgba(249,115,22,.22) 0%, transparent 62%),
      linear-gradient(135deg, var(--bgA), var(--bgB));
    display:flex;
    justify-content:center;
  }

  .app{
    width:min(1150px, 96vw);
    padding:18px 14px 24px;
  }

  /* Header */
  .header{
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap:12px;
    flex-wrap:wrap;
    margin-bottom:12px;
  }

  .brand{
    display:flex; align-items:center; gap:10px;
    padding:12px 14px;
    background:var(--card);
    border:1px solid var(--line);
    border-radius:18px;
    box-shadow: var(--shadow);
  }
  .logo{
    width:42px; height:42px; border-radius:16px;
    background: conic-gradient(from 180deg, var(--green), var(--orange), var(--lemon), var(--green2), var(--orange2), var(--green));
    box-shadow: 0 10px 20px rgba(34,197,94,.18);
  }
  .brand h1{
    margin:0;
    font-size:16px;
    line-height:1.1;
    letter-spacing:.4px;
  }
  .brand p{
    margin:3px 0 0;
    font-size:12px;
    color:var(--muted);
  }

  .stats{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    align-items:center;
  }
  .pill{
    background:var(--card);
    border:1px solid var(--line);
    border-radius:999px;
    padding:10px 12px;
    box-shadow: var(--shadow);
    display:flex;
    gap:8px;
    align-items:center;
    font-size:13px;
    font-weight:900;
    color:rgba(24,48,40,.92);
  }
  .dot{
    width:10px; height:10px; border-radius:50%;
    background: var(--green);
    box-shadow: 0 0 0 4px rgba(34,197,94,.14);
  }
  .dot.score{ background: var(--orange); box-shadow: 0 0 0 4px rgba(249,115,22,.16); }
  .dot.merge{ background: var(--lemon); box-shadow: 0 0 0 4px rgba(253,224,71,.20); }

  button{
    border:none;
    background: linear-gradient(135deg, var(--green2), var(--orange2));
    color:white;
    padding:10px 12px;
    border-radius:14px;
    font-weight:900;
    cursor:pointer;
    box-shadow: 0 12px 20px rgba(249,115,22,.16);
    transition: transform .08s ease;
  }
  button:active{ transform: scale(.98); }
  button.secondary{
    background: linear-gradient(135deg, #ffffff, #fff7ed);
    color:var(--ink);
    border:1px solid var(--line);
    box-shadow: var(--shadow);
  }

  /* Layout */
  .layout{
    display:grid;
    grid-template-columns: 1fr 280px;
    gap:12px;
    align-items:start;
  }

  .card{
    background:var(--card);
    border:1px solid var(--line);
    border-radius:22px;
    box-shadow: var(--shadow);
    padding:14px;
  }

  /* Target slots */
  .targetTitle{
    display:flex;
    justify-content:space-between;
    align-items:flex-start;
    gap:10px;
    flex-wrap:wrap;
    margin-bottom:10px;
  }
  .targetTitle h2{
    margin:0;
    font-size:16px;
  }
  .sub{
    margin:6px 0 0;
    color:var(--muted);
    font-size:12px;
    line-height:1.35;
  }

  .slotsRow{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    align-items:center;
    margin-top:10px;
  }
  .slot{
    width:64px;
    height:64px;
    border-radius:18px;
    background: linear-gradient(135deg, rgba(34,197,94,.14), rgba(249,115,22,.12));
    border: 2px dashed rgba(34,197,94,.35);
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:26px;
    font-weight:900;
    user-select:none;

    /* faint by default */
    color: rgba(24,48,40,.22);
    transition: transform .10s ease, border-color .10s ease, background .10s ease, color .10s ease, box-shadow .10s ease;
  }
  .slot.over{
    transform: translateY(-2px);
    border-color: rgba(249,115,22,.65);
    box-shadow: 0 16px 30px rgba(249,115,22,.18);
  }
  .slot.filled{
    border-style:solid;
    background: linear-gradient(135deg, rgba(34,197,94,.25), rgba(253,224,71,.22));
    border-color: rgba(34,197,94,.55);
    color: rgba(24,48,40,.96); /* vivid */
    box-shadow: 0 14px 18px rgba(16,24,40,.08);
  }

  /* Grid */
  .grid{
    margin-top:14px;
    display:grid;
    grid-template-columns: repeat(7, 1fr);
    gap:9px;
  }
  .cell{
    height:58px;
    border-radius:18px;
    background: linear-gradient(135deg, var(--cell), var(--cell2));
    border: 1px solid rgba(17,24,39,.07);
    box-shadow: 0 12px 16px rgba(16,24,40,.06);
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:22px;
    font-weight:900;
    user-select:none;
    cursor:pointer;
    position:relative;
    transition: transform .10s ease, box-shadow .10s ease, outline-color .10s ease;
  }
  .cell:hover{
    transform: translateY(-1px);
    box-shadow: 0 14px 18px rgba(16,24,40,.08);
  }
  .cell.selected{
    outline: 3px solid rgba(249,115,22,.75);
    outline-offset: 2px;
    transform: translateY(-2px) scale(1.02);
  }
  .cell.pop{ animation: pop .16s ease-in-out; }
  @keyframes pop{
    0%{ transform: scale(.98); }
    60%{ transform: scale(1.06); }
    100%{ transform: scale(1); }
  }

  /* Storage */
  .storageTitle{
    display:flex;
    align-items:center;
    justify-content:space-between;
    margin-bottom:10px;
  }
  .storageTitle h3{ margin:0; font-size:15px; }
  .hint{
    color:var(--muted);
    font-size:12px;
    line-height:1.35;
  }
  .slots{
    display:grid;
    grid-template-rows: repeat(5, 58px);
    gap:9px;
  }
  .stash{
    height:58px;
    border-radius:18px;
    background: rgba(255,255,255,.55);
    border: 2px dashed rgba(24,48,40,.18);
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:900;
    font-size:20px;
    color: rgba(24,48,40,.74);
    transition: transform .10s ease, border-color .10s ease, box-shadow .10s ease;
    user-select:none;
  }
  .stash.filled{
    background: linear-gradient(135deg, rgba(255,255,255,.92), rgba(255,247,237,.88));
    border-style:solid;
    box-shadow: 0 12px 16px rgba(16,24,40,.06);
  }
  .stash.over{
    transform: translateY(-2px);
    border-color: rgba(34,197,94,.70);
    box-shadow: 0 16px 20px rgba(34,197,94,.12);
  }

  .toast{
    position:fixed;
    left:50%;
    transform:translateX(-50%);
    bottom:18px;
    padding:10px 12px;
    border-radius:999px;
    background: rgba(255,255,255,.92);
    border:1px solid rgba(17,24,39,.08);
    box-shadow: var(--shadow);
    font-size:13px;
    font-weight:900;
    color: rgba(24,48,40,.92);
    opacity:0;
    pointer-events:none;
    transition: opacity .18s ease, transform .18s ease;
  }
  .toast.show{
    opacity:1;
    transform:translateX(-50%) translateY(-2px);
  }

  @media (max-width: 980px){
    .layout{ grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
<div class="app">

  <div class="header">
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div>
        <h1>FOR EILEEN</h1>
        <p>Merge letters ¬∑ Drag to solve ¬∑ Store 5</p>
      </div>
    </div>

    <div class="stats">
      <div class="pill"><span class="dot"></span>Level: <span id="level">1</span></div>
      <div class="pill"><span class="dot score"></span>Score: <span id="score">0</span></div>
      <div class="pill"><span class="dot merge"></span>Merge: click 2 same letters ‚Üí upgrade</div>
      <button class="secondary" id="resetBtn">Reset</button>
    </div>
  </div>

  <div class="layout">
    <div class="card">
      <div class="targetTitle">
        <div>
          <h2>Target Word</h2>
          <p class="sub" id="targetHint"></p>
        </div>
      </div>

      <div class="slotsRow" id="targetSlots"></div>

      <div class="hint" style="margin-top:10px">
        Drag a letter from the grid onto the matching target slot.
        The slot turns vivid when filled. You level up only when all slots are filled.
      </div>

      <div class="grid" id="grid"></div>

      <div class="hint" style="margin-top:10px">
        Storage: Drag a grid letter to an empty storage slot to save it (grid refills immediately).
        Drag from storage back onto the grid to swap.
      </div>
    </div>

    <div class="card">
      <div class="storageTitle">
        <h3>Storage (5)</h3>
      </div>
      <div class="slots" id="storageSlots"></div>
      <div class="hint" style="margin-top:10px" id="difficultyHint"></div>
    </div>
  </div>
</div>

<div class="toast" id="toast">Nice!</div>

<script>
/* =============================
   Core State
============================= */
const SIZE = 7;
const LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");

// Curated word pools: early words use early letters; later pools include later letters.
// (You can expand this list freely‚Äîsystem will scale difficulty automatically.)
const WORDS = [
  // EASY (mostly A-H, 3 letters)
  "BAD","BAG","BAR","BAT","CAB","CAN","CAP","CAR","CAT","DAB","DAD","DAN","DAY",
  "EAR","EAT","FAN","FAR","FAT","GAS","GAP","HAT","HAD","HEN","HIM",

  // MEDIUM (3-4 letters, still mostly early letters)
  "BARK","BAND","BANK","BEAR","BEAD","BEAT","BELL","BEND","BEND","BIRD","BITE",
  "BOAT","BOOK","BREAD","CAMP","CART","CAVE","CODE","COOL","COLD","DARK","DEAL",
  "DEEP","DICE","DISH","ECHO","FIRE","FISH","FORK","GAME","GATE","GOLD","GOOD","HOME",

  // HARDER (4-5 letters, introduce I-N/O)
  "APPLE","BRICK","CLOUD","DANCE","GLASS","GREEN","HONEY","HOUSE","LIGHT","MOUSE",
  "MUSIC","NIGHT","OCEAN","PLANE","PLANT","POINT","POWER","RIVER","SHEEP","SHARK","SNAKE","SUGAR","TABLE","TRAIN",

  // LATE (5+ letters, more late letters like V/W/X/Y/Z appear)
  "WORLD","WHITE","BLACK","SWORD","MAGIC","UNITY","SWIFT",
  "JAZZ","FUZZ","BUZZ","QUIZ","JINX","VEX","WAX","YAWN","ZANY",
  "ZOOM","ZEST","ZERO","ZEBRA"
];

let level = 1;
let score = 0;

let grid = [];                 // 7x7 letters
let selected = null;           // {r,c}
let storage = Array(5).fill(null);

let targetWord = "";
let targetFilled = [];         // boolean[] for each letter position

/* =============================
   Difficulty Design (fair curve)
   - At low levels: short words + early letters only
   - Higher levels: longer + allows later letters (but still controlled)
============================= */
function letterIndex(ch){ return LETTERS.indexOf(ch); }
function wordMaxLetterIndex(word){
  let m = 0;
  for(const ch of word) m = Math.max(m, letterIndex(ch));
  return m;
}

function levelParams(lv){
  // Balanced curve inspired by typical puzzle progression:
  // increase both word length and allowed max letter gradually.
  if(lv <= 2)  return {lenMin:3, lenMax:3, cap:"H"};
  if(lv <= 5)  return {lenMin:3, lenMax:4, cap:"K"};
  if(lv <= 9)  return {lenMin:4, lenMax:4, cap:"N"};
  if(lv <= 14) return {lenMin:4, lenMax:5, cap:"R"};
  if(lv <= 20) return {lenMin:5, lenMax:6, cap:"V"};
  return          {lenMin:5, lenMax:7, cap:"Z"};
}

function pickTargetWord(){
  const p = levelParams(level);
  const capIdx = letterIndex(p.cap);

  // Candidate words that fit current "fair" difficulty window
  let candidates = WORDS.filter(w =>
    w.length >= p.lenMin &&
    w.length <= p.lenMax &&
    wordMaxLetterIndex(w) <= capIdx
  );

  // If too strict (rare), relax in a safe order
  if(candidates.length < 6){
    candidates = WORDS.filter(w => w.length >= p.lenMin && w.length <= p.lenMax);
  }
  if(candidates.length === 0){
    candidates = WORDS.slice();
  }

  // Weighted pick: prefer words near the top of the current window (keeps progression feeling)
  // weight = 1 + (maxLetterIdx/capIdx) + (length/lenMax)
  const weights = candidates.map(w => {
    const mx = wordMaxLetterIndex(w);
    const w1 = 1 + (capIdx ? (mx / Math.max(1, capIdx)) : 0) + (w.length / Math.max(1, p.lenMax));
    return w1;
  });
  let sum = weights.reduce((a,b)=>a+b,0);
  let r = Math.random() * sum;
  for(let i=0;i<candidates.length;i++){
    r -= weights[i];
    if(r <= 0){
      targetWord = candidates[i];
      break;
    }
  }
  if(!targetWord) targetWord = candidates[Math.floor(Math.random()*candidates.length)];
  targetFilled = Array.from({length: targetWord.length}, () => false);
}

/* =============================
   Spawn distribution (rarity)
   - Higher levels make late letters rarer overall
   - This keeps ‚ÄúZ is hard‚Äù even when allowed.
============================= */
function rarityAlphaForLevel(lv){
  // Slightly stronger than before, but still playable
  // lv 1: 1.25, lv 10: 2.10, lv 25+: ~3.20
  return Math.min(3.2, 1.15 + lv * 0.095);
}

function randomLetterByLevel(lv){
  const alpha = rarityAlphaForLevel(lv);
  let sum = 0;
  const weights = [];
  for(let i=0;i<LETTERS.length;i++){
    const w = 1 / Math.pow(i+1, alpha);
    weights.push(w);
    sum += w;
  }
  let r = Math.random() * sum;
  for(let i=0;i<weights.length;i++){
    r -= weights[i];
    if(r <= 0) return LETTERS[i];
  }
  return "A";
}

function nextLetter(ch){
  const i = LETTERS.indexOf(ch);
  return (i >= 0 && i < 25) ? LETTERS[i+1] : "Z";
}

/* =============================
   Board / UI helpers
============================= */
function fillBoardFull(){
  grid = Array.from({length: SIZE}, () =>
    Array.from({length: SIZE}, () => randomLetterByLevel(level))
  );
}

function toast(msg){
  const t = document.getElementById("toast");
  t.textContent = msg;
  t.classList.add("show");
  setTimeout(() => t.classList.remove("show"), 900);
}

function safeParse(s){ try{ return JSON.parse(s); } catch { return null; } }

/* =============================
   Merge by clicking 2 cells (any distance)
   - same letter => upgrade second, respawn first (board always full)
============================= */
function tapCell(r,c){
  if(!selected){
    selected = {r,c};
    renderGrid();
    animateCell(r,c);
    return;
  }

  const a = selected;
  const b = {r,c};

  if(a.r === b.r && a.c === b.c){
    selected = null;
    renderGrid();
    return;
  }

  const chA = grid[a.r][a.c];
  const chB = grid[b.r][b.c];

  if(chA === chB){
    grid[b.r][b.c] = nextLetter(chB);
    grid[a.r][a.c] = randomLetterByLevel(level);
    score += 10;
    animateCell(b.r,b.c);
  }

  selected = null;
  renderAll();
}

function animateCell(r,c){
  const el = document.getElementById(`cell-${r}-${c}`);
  if(!el) return;
  el.classList.remove("pop");
  void el.offsetWidth; // reflow
  el.classList.add("pop");
}

/* =============================
   Drag: grid letter -> target slot (solve)
============================= */
function tryFillSlot(slotIndex, payload){
  const need = targetWord[slotIndex];
  const letter = payload.letter;

  if(targetFilled[slotIndex]) {
    toast("Slot already filled üôÇ");
    return;
  }
  if(letter !== need){
    toast("Wrong letter üòÖ");
    return;
  }

  // Success
  targetFilled[slotIndex] = true;
  grid[payload.r][payload.c] = randomLetterByLevel(level);
  score += 25;

  // If all filled => level up
  if(targetFilled.every(Boolean)){
    score += 250 + level * 35;
    level += 1;

    // pressure reroll a few cells (keeps late game moving)
    for(let i=0;i<6;i++){
      const rr = Math.floor(Math.random()*SIZE);
      const cc = Math.floor(Math.random()*SIZE);
      grid[rr][cc] = randomLetterByLevel(level);
    }

    toast(`Solved! Level ${level} üéâ`);
    pickTargetWord();
  } else {
    toast("Nice! üëç");
  }

  renderAll();
}

/* =============================
   Storage drag & drop
============================= */
function allowDrop(ev){ ev.preventDefault(); }

function onDragStartFromGrid(r,c, ev){
  const payload = {from:"grid", r, c, letter: grid[r][c]};
  ev.dataTransfer.setData("text/plain", JSON.stringify(payload));
  ev.dataTransfer.effectAllowed = "move";
}

function onDragStartFromStorage(i, ev){
  if(storage[i] == null) return;
  const payload = {from:"storage", slotIndex:i, letter: storage[i]};
  ev.dataTransfer.setData("text/plain", JSON.stringify(payload));
  ev.dataTransfer.effectAllowed = "move";
}

function dropOnStorage(i, ev){
  ev.preventDefault();
  const data = safeParse(ev.dataTransfer.getData("text/plain"));
  if(!data || data.from !== "grid") return;

  if(storage[i] != null) {
    toast("Storage slot is not empty!");
    return;
  }

  storage[i] = data.letter;
  grid[data.r][data.c] = randomLetterByLevel(level); // refill immediately
  score += 1;
  selected = null;
  renderAll();
}

function dropOnGridCell(r,c, ev){
  ev.preventDefault();
  const data = safeParse(ev.dataTransfer.getData("text/plain"));
  if(!data || data.from !== "storage") return;

  const i = data.slotIndex;
  const tmp = grid[r][c];
  grid[r][c] = storage[i];
  storage[i] = tmp;
  selected = null;
  renderAll();
}

/* =============================
   Render
============================= */
const elLevel = document.getElementById("level");
const elScore = document.getElementById("score");
const elGrid = document.getElementById("grid");
const elTargetSlots = document.getElementById("targetSlots");
const elTargetHint = document.getElementById("targetHint");
const elStorageSlots = document.getElementById("storageSlots");
const elDifficultyHint = document.getElementById("difficultyHint");

function renderTop(){
  elLevel.textContent = String(level);
  elScore.textContent = String(score);

  const p = levelParams(level);
  const capIdx = letterIndex(p.cap);

  const mx = wordMaxLetterIndex(targetWord);
  const mxChar = LETTERS[mx] || "A";

  elTargetHint.textContent =
    `Level rules: word length ${p.lenMin}-${p.lenMax}, letters up to ${p.cap}. ` +
    `Current target max letter: ${mxChar}. Drag letters into slots to solve.`;

  const alpha = rarityAlphaForLevel(level).toFixed(2);
  elDifficultyHint.textContent =
    `Difficulty curve: early levels use easy words (early letters). Higher levels unlock longer words and later letters. ` +
    `Spawn rarity Œ±=${alpha} (later letters are naturally rarer).`;
}

function renderTarget(){
  elTargetSlots.innerHTML = "";
  for(let i=0;i<targetWord.length;i++){
    const need = targetWord[i];
    const slot = document.createElement("div");
    slot.className = "slot";
    slot.textContent = need;

    if(targetFilled[i]) slot.classList.add("filled");

    slot.addEventListener("dragover", allowDrop);
    slot.addEventListener("dragenter", () => slot.classList.add("over"));
    slot.addEventListener("dragleave", () => slot.classList.remove("over"));
    slot.addEventListener("drop", (ev) => {
      ev.preventDefault();
      slot.classList.remove("over");
      const data = safeParse(ev.dataTransfer.getData("text/plain"));
      if(!data || data.from !== "grid") return;
      tryFillSlot(i, data);
    });

    elTargetSlots.appendChild(slot);
  }
}

function renderGrid(){
  elGrid.innerHTML = "";
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      const d = document.createElement("div");
      d.className = "cell";
      d.id = `cell-${r}-${c}`;
      if(selected && selected.r === r && selected.c === c) d.classList.add("selected");
      d.textContent = grid[r][c];
      d.setAttribute("draggable", "true");

      d.addEventListener("click", () => tapCell(r,c));
      d.addEventListener("dragstart", (ev) => onDragStartFromGrid(r,c, ev));

      d.addEventListener("dragover", allowDrop);
      d.addEventListener("drop", (ev) => dropOnGridCell(r,c, ev));

      elGrid.appendChild(d);
    }
  }
}

function renderStorage(){
  elStorageSlots.innerHTML = "";
  for(let i=0;i<5;i++){
    const s = document.createElement("div");
    s.className = "stash";
    if(storage[i] != null) s.classList.add("filled");
    s.textContent = storage[i] ? storage[i] : "Empty";

    if(storage[i] != null){
      s.setAttribute("draggable","true");
      s.addEventListener("dragstart", (ev) => onDragStartFromStorage(i, ev));
    }

    s.addEventListener("dragover", allowDrop);
    s.addEventListener("dragenter", () => s.classList.add("over"));
    s.addEventListener("dragleave", () => s.classList.remove("over"));
    s.addEventListener("drop", (ev) => {
      s.classList.remove("over");
      dropOnStorage(i, ev);
    });

    elStorageSlots.appendChild(s);
  }
}

function renderAll(){
  renderTop();
  renderTarget();
  renderGrid();
  renderStorage();
}

/* =============================
   Init
============================= */
function resetGame(){
  level = 1;
  score = 0;
  selected = null;
  storage = Array(5).fill(null);

  fillBoardFull();
  pickTargetWord();
  renderAll();
}

document.getElementById("resetBtn").addEventListener("click", resetGame);
resetGame();
</script>
</body>
</html>
